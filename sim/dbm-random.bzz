include "buzz_includes/buzz_utils/vec2.bzz"
include "buzz_includes/buzz_utils/string.bzz"
include "config/DBM-SMS/parameters.bzz"
include "buzz_includes/DBM-SMS/global_variables.bzz"
include "buzz_includes/debug.bzz"


ARENA_SIZE_X = 50
ARENA_SIZE_Y = 50

EXPLORATION_WEIGHT = 1.0
RISK_WEIGHT = 1.0

var stigmergy_risk
var stigmergy_exploration


function init_stigmergies() {
  stigmergy_risk = stigmergy.create(1)
  stigmergy_risk.onconflict(function(k, l, r){
    merged = l
    merged_data = l.data * 0.5 + r.data * 0.5
    merged.data = merged_data
    return merged
    })

  stigmergy_exploration = stigmergy.create(2)
  stigmergy_exploration.onconflict(function(k, l, r){
    merged = l
    merged_data = l.data * 0.5 + r.data * 0.5
    merged.data = merged_data
    return merged
    })
}

function update_risk() {
  stigmergy_risk.put(get_current_key(), get_radiation_intensity())  # Put timestamp in exploration map
}

function update_exploration() {
  stigmergy_exploration.put(get_current_key(), current_step)  # Put timestamp in exploration map
}

function exploration_gradient(adjacent_key) {
  if (stigmergy_exploration.get(adjacent_key) != nil) {
    return current_step - stigmergy_exploration.get(adjacent_key)
  } else {
    return current_step
  }
}

function risk_gradient(adjacent_key) {
  if (stigmergy_risk.get(adjacent_key) != nil) {
    return get_radiation_intensity() - stigmergy_risk.get(adjacent_key)
  } else {
    return 0.0
  }
}

function get_adjacent_key(i, j) {
  split_key = string.split(get_current_key(), "_")
  key_x = string.toint(split_key[0]) + i
  key_y = string.toint(split_key[1]) + j

  return string.concat(string.tostring(key_x), "_", string.tostring(key_y))
}

# Safely normalize a vector. 
# If input vector is (0, 0), return a random vector to avoid division by zero.
function safe_normalize(vector) {
  if (vector.x == 0 and vector.y == 0) {
    return math.vec2.new(math.rng.uniform(-0.5, 0.5), math.rng.uniform(-0.5, 0.5))
  } else {
    return math.vec2.norm(vector)
  }
}

function gradient(gradient_function){
  var i = -1
  var j = -1
  var gradient_vec = math.vec2.new(0.0, 0.0)

  while (i <= 1){
    j = -1
    while (j <= 1){
      if (not(i == 0 and j == 0)){
        gradient_intensity = gradient_function(get_adjacent_key(i, j))
        adjacent_gradient = math.vec2.scale(math.vec2.norm(math.vec2.new(i, j)), gradient_intensity)

        gradient_vec = math.vec2.add(gradient_vec, adjacent_gradient)
      }
      j = j + 1
    }
    i = i + 1
  }

  return safe_normalize(gradient_vec)
}

# Executed at init time
function init() {
  # Take off command for the Spiri drone model
  takeoff()

  # Show trajectory for debugging
  show_colored_trajectory(NUMBER_OF_ROBOTS)

  # Set first search position
  next_position.x = uniform(SEARCH_SPACE.minx, SEARCH_SPACE.maxx)
  next_position.y = uniform(SEARCH_SPACE.miny, SEARCH_SPACE.maxy)

  init_stigmergies()
}

function move() {
  exploration = math.vec2.scale(gradient(exploration_gradient), EXPLORATION_WEIGHT)
  risk = math.vec2.scale(gradient(risk_gradient), RISK_WEIGHT)

  norm_direction = safe_normalize(math.vec2.add(exploration, risk))
  scaled_direction = math.vec2.scale(norm_direction, SEARCH_SPEED)

  goto(scaled_direction.x, scaled_direction.y)
}

# Executed every time step
function step() {
  if (current_step < EXPERIMENT_LENGHT) {
    if (current_step % NEW_POSE_DELAY) {
      update_exploration()
      update_risk()

      move()
    }
    current_step = current_step + 1
  } 
  else if (current_step == EXPERIMENT_LENGHT and id == 0) {
    stigmergy_risk.foreach(function(key, data, robot){
      log_datum(key, data)
    })
  }
}

function reset() {
}
 
# Execute at exit
function destroy() {
}
