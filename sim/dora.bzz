include "buzz_includes/buzz_utils/vec2.bzz"
include "buzz_includes/buzz_utils/table.bzz"
include "buzz_includes/buzz_utils/string.bzz"
include "config/DBM-SMS/parameters.bzz"
include "buzz_includes/DBM-SMS/global_variables.bzz"
include "buzz_includes/buzz_utils/obstacle_avoidance.bzz"
include "buzz_includes/buzz_utils/goto.bzz"
include "buzz_includes/buzz_utils/current_key.bzz"
include "buzz_includes/buzz_utils/radiation.bzz"
include "buzz_includes/buzz_utils/radiation_sensor.bzz"
include "buzz_includes/buzz_utils/logging.bzz"


EXPLORATION_GAIN = 1.0
RISK_GAIN = 0
NO_FAIL_DELAY = 20

var stigmergy_risk
var stigmergy_exploration


function key_to_vec2(key) {
  split_key = string.split(get_current_key(), "_")
  x = string.toint(split_key[0])
  y = string.toint(split_key[1])

  return math.vec2.new(x, y)
}

function init_stigmergies() {
  stigmergy_risk = stigmergy.create(1)
  stigmergy_risk.onconflict(function(k, l, r){
    return l
    })

  stigmergy_exploration = stigmergy.create(2)
  stigmergy_exploration.onconflict(function(k, l, r){
    return l
    })
}

function update_risk() {
  new_value = radiation_sensor.get_total_perceived_radiation(sensor, pose.position.x, pose.position.y) + math.rng.gaussian(0,0.1)
  current_key = get_current_key(pose.position.x, pose.position.y)
  # log("Radiation: ", new_value, ", key: ", current_key, "count: ", stigmergy_risk.size())
  if (stigmergy_risk.get(current_key) != nil){
    new_value = 0.5 * new_value + 0.5 * stigmergy_risk.get(current_key)
  }
  stigmergy_risk.put(current_key, new_value)
}

function update_exploration() {
  stigmergy_exploration.put(get_current_key(pose.position.x, pose.position.y), current_step)  # Put timestamp in exploration map
}

function position_in_bounds(position){
  return position.x <= SEARCH_SPACE_DORA.maxx and position.x >= SEARCH_SPACE_DORA.minx and position.y <= SEARCH_SPACE_DORA.maxy and position.y >= SEARCH_SPACE_DORA.miny
}

function exploration_gradient(adjacent_key, i, j) {
  if (position_in_bounds(get_adjacent_position(i,j))){
    exploration_adjacent = stigmergy_exploration.get(adjacent_key)
    if (exploration_adjacent!= nil) {
      return current_step - exploration_adjacent
    } else {
        return current_step
    }
  } else {
      return 0.0
  }
}

function risk_gradient(adjacent_key) {
  risk_adjacent = stigmergy_risk.get(adjacent_key)
  if (risk_adjacent != nil) {
    return radiation_sensor.get_total_perceived_radiation(sensor, pose.position.x, pose.position.y) - risk_adjacent 
  } else {
    return 0.0
  }
}

function get_adjacent_key(i, j) {
  split_key = string.split(get_current_key(pose.position.x, pose.position.y), "_")
  key_x = string.toint(split_key[0]) + i
  key_y = string.toint(split_key[1]) + j

  return string.concat(string.tostring(key_x), "_", string.tostring(key_y))
}

function get_adjacent_position(i, j) {
  split_key = string.split(get_current_key(pose.position.x, pose.position.y), "_")
  x = string.toint(split_key[0]) + i
  y = string.toint(split_key[1]) + j

  return math.vec2.new(x,y)
}

# Safely normalize a vector. 
function safe_normalize(vector) {
  if (vector.x == 0 and vector.y == 0) {
    return vector
  } else {
    return math.vec2.norm(vector)
  }
}

function gradient(gradient_function){
  var i = -1
  var j = -1
  var gradient_vec = math.vec2.new(0.0, 0.0)

  while (i <= 1){
    j = -1
    while (j <= 1){
      if (not(i == 0 and j == 0)){
        gradient_intensity = gradient_function(get_adjacent_key(i, j),i,j)
        # log("Gradient with neighbor at ", i, ":", j, " is : ", gradient_intensity)
        adjacent_gradient = math.vec2.scale(math.vec2.norm(math.vec2.new(i, j)), gradient_intensity)
        gradient_vec = math.vec2.add(gradient_vec, adjacent_gradient)
      }
      j = j + 1
    }
    i = i + 1
  }

  #if gradient too small ignore it
  if (math.abs(math.vec2.length(gradient_vec)) < 0.01) {
    return math.vec2.new(0.0, 0.0)
  } else {
    return safe_normalize(gradient_vec)
  }
}

function move() {
  log("Exploration")
  exploration = math.vec2.scale(gradient(exploration_gradient), EXPLORATION_GAIN)
  risk = math.vec2.scale(gradient(risk_gradient), RISK_GAIN)

  if (close_to_obstacle()){
    obstacle_avoidance = avoid_obstacle()
  } else {
      obstacle_avoidance = math.vec2.new(0.0,0.0)
  }

  risk_direction_local = to_local_coordinates(risk, pose.orientation.yaw)
  exploration_direction_local = to_local_coordinates(exploration, pose.orientation.yaw)

  norm_direction = math.vec2.add(exploration_direction_local, risk_direction_local)
  norm_direction_avoidance = math.vec2.add(norm_direction, math.vec2.new(0.0, 0.0))
  table.print(norm_direction_avoidance)

  gotoc_buzz(norm_direction_avoidance)
}

function to_local_coordinates(vector, yaw) {
  if (vector.x != 0.0 or vector.y != 0.0){
    return math.vec2.rotate(vector, -yaw)
  } else {
    return math.vec2.new(1.0, 0.0)
  }
}

function failure() {
  rand = math.rng.uniform(0.2, 1.0)
  intensity = radiation_sensor.get_total_perceived_radiation(sensor, pose.position.x, pose.position.y)
  if (current_step > NO_FAIL_DELAY and rand < intensity) {
    log("Robot ", id, ": Failure with ", intensity," > ", rand)
    return 1
  }
  return 0
}

# Executed at init time
function init() {
  log("I am robot: ", id)

  init_stigmergies()
  failed = 0
  math.rng.setseed(id)

  sources = { .0 = radiation_source.new(0.0, 0.0, 0.5)}
  sensor = radiation_sensor.new(sources)

  csv_logger.init()
}

# Executed every time step
function step() {
  if (current_step < EXPERIMENT_LENGHT) {
    if (failed == 0) {
      # stigmergy_exploration.foreach(function(k, v, rid) { log(k, ":", v) })
      log("-----------------------------------------------------------")
      update_exploration()
      update_risk()
      move()
      update_previous_sensor_readings()
      failed = failure()
    }
    csv_logger.log_data(pose.position.x, pose.position.y, radiation_intensity, current_step)
  }

  if (current_step > EXPERIMENT_LENGHT or failed != 0){
    set_wheels(0.0,0.0)
    log("Experiment terminated")
  }

  current_step = current_step + 1
}

function reset() {
}
 
# Execute at exit
function destroy() {
}
